# required functions to get everything that we need
import subprocess
import json
from datetime import datetime, timedelta

import pandas as pd

def execute_command(command):

    """
    Execute a CLI command and return the output and error messages.
    Parameters:
    -  command [str]: The CLI command to execute.

    Returns:
    - output (str): The output generated by the command. 
                    A zip file containing the NFDB fire polygons (for large fires)
    - error (str): The error message generated by the command, if any.

    """

    try:

        # execute the command and capture the output and error messages

        process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        output, error = process.communicate()

        output = output.decode("utf-8")
        error = error.decode("utf-8")

        # return the output and error messages
        return output, error

    except Exception as e:

        # if an exception occurs, return the exception message as an error
        return None, str(e)


def closest_below(lst, target):
    below_target = [x for x in lst if x < target]
    return max(below_target, default=None)


# function to set files names
def set_filenames(model, run, year, month, day, hour, forecast_length, offset):
    """
        Set the filenames based on the model, run, year, month, day, and forecast length.
        Paramters are selected in define_vars.ipynb - funciton also loads specific model variables from JSON files.

        model: str - the model name (e.g., 'rdps', 'hrdps')
        Returns a DataFrame with the full path, extension, and file name for each forecast hour.

        input variables are all determined by sliders which are set in define_vars.ipynb
    """
    import pandas as pd

    print(f"Selected Model: {model}")
    print(f"Selected Model Run: {run}")
    print(f"Selected Date: {year}-{month:02d}-{day:02d}--{hour:02d}")
    print(f"Forecast Length: {forecast_length} hours")

    file_list = pd.DataFrame(columns=['full_path', 'extension', 'file', 'variable', 'datetime'])
    # Create the filename based on the selections
    if str(model) == 'rdps':
        # load the rdps_vars.json file
        with open('rdps_vars.json', 'r') as f:
            model_vars = json.load(f)
    elif str(model) == 'hrdps':
        # load the hrdps_vars.json file
        with open('hrdps_vars.json', 'r') as f:
            model_vars = json.load(f)

    if run == 'auto':
        # get the nearest model initialization time
        model_initialization_time = [0, 6, 12, 18]
        select_model_init = closest_below(model_initialization_time, int(hour))

        # this is the forecast hour that we need to start at from the selected model run
        h1 = int(hour) - select_model_init

    else: 
        # for when the user specifies a model run to use 
        h1 = hour - run

    print("The model starts at ")

    # simple countr of the number of hours that have been processed
    hours_run = 0
    for hh in range(h1, h1+forecast_length):
        if run == 'auto':
            run = f"{select_model_init:02d}"
        # note that we start from the 1 hr forecast
        extension = f"https://dd.weather.gc.ca/{year}{month:02d}{day:02d}/WXO-DD/model_{model}/{model_vars['configuration']['resolution']}/{run}/0{hh:02d}/"
            
        for ii in range(len(model_vars['wx_vars'])):  #model_vars['wx_vars'].values():
            var = list(model_vars['wx_vars'].values())[ii]
            quick_var = list(model_vars['grib_vars'].values())[ii]

            if hh == 0 and var == "Precip-Accum1h_Sfc":
                # nicer to grab the previous model run 6h forecast so we can include any 0h precip
                file = f"{year}{month:02d}{day:02d}T{run-6}Z_MSC_{model.upper()}_{var}_RLatLon{model_vars['configuration']['grid']}_PT0{hh+6:02d}H.grib2"
            else:
                # otherwise loop through and grab the date in the loop
                file = f"{year}{month:02d}{day:02d}T{run}Z_MSC_{model.upper()}_{var}_RLatLon{model_vars['configuration']['grid']}_PT0{hh:02d}H.grib2"

            # get a datetime variable and add it to the dataframe - this moves it to the local time set by the user
            timestamp = datetime(int(year), int(month), int(day), int(hour)) - timedelta(hours=int(offset)) + timedelta(hours=int(hours_run))


            print(timestamp, file)

            # populate the file_list DataFrame
            new_row = {
                'full_path': extension + file,
                'extension': extension,
                'file': file,
                'variable': quick_var,
                'datetime': timestamp
            }
            file_list.loc[len(file_list)] = new_row
        
        hours_run += 1

    return file_list